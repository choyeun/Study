---
date created: 목요일, 3월 27일 2025, 9:13:47 오후
date modified: 목요일, 3월 27일 2025, 9:14:07 오후
title: 0327 숙제
---

# 0327 숙제

원본 소스코드는 아레와 같습니다
```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_STACK_SIZE 100
#define MAZE_SIZE 6 // 추가: MAZE_SIZE 정의
typedef struct {
    short row;
    short column;
} element;
typedef struct {
    element data[MAX_STACK_SIZE];
    int top;
} StackType;
// 스택 초기화 함수
void init_stack(StackType* stack)
{
    stack->top = -1;
}
// 공백 상태 검출 함수
int is_empty(StackType* stack)
{
    return (stack->top == -1);
}
// 포화 상태 검출 함수
int is_full(StackType* stack)
{
    return (stack->top == (MAX_STACK_SIZE - 1));
}
// 삽입함수
void push(StackType* stakc, element item)
{
    if (is_full(stakc)) {
        fprintf(stderr, "스택 포화 에러\n");
        return;
    }
    else stakc->data[++(stakc->top)] = item;
}
// 삭제함수
element pop(StackType* stack)
{
    if (is_empty(stack)) {
        fprintf(stderr, "스택 공백 에러\n");
        exit(1);
    }
    else return stack->data[(stack->top)--];
}
element here = { 1,0 }, entry = { 1,0 };
char maze[MAZE_SIZE][MAZE_SIZE] = {
    { '1', '1', '1', '1', '1', '1' },
    { 'e', '0', '1', '0', '0', '1' },
    { '1', '0', '0', '0', '1', '1' },
    { '1', '0', '1', '0', '1', '1' },
    { '1', '0', '1', '0', '0', 'x' },
    { '1', '1', '1', '1', '1', '1' },
};
// 위치를 스택에 삽입
void push_loc(StackType* stack, int row, int column)
{
    if (row < 0 || column < 0) return; // 수정: 범위 검사 추가
    if (maze[row][column] != '1' && maze[row][column] != '.') { // '1'과 '.'인 경우 제외
        element tmp;
        tmp.row = row;
        tmp.column = column;
        push(stack, tmp);
    }
}
// 미로를 화면에 출력한다.
void maze_print(char maze[MAZE_SIZE][MAZE_SIZE])
{
    printf("\n");
    for (int row = 0; row < MAZE_SIZE; row++) {
        for (int column = 0; column < MAZE_SIZE; column++) {
            printf("%c", maze[row][column]);
        }
        printf("\n");
    }
}
void stack_print(StackType* stack) {
    printf("\n현재 스택의 내용:\n");
    if (is_empty(stack)) {
        printf("스택이 비어 있음\n");
        return;
    }
    
    printf("스택 바닥[");
    for (int i = 0; i <= stack->top; i++) {
        printf("(%d,%d)", stack->data[i].row, stack->data[i].column);
        if (i < stack->top) printf(", ");
    }
    printf("] 스택 상단\n");
}
int main(void)
{
    int row, column;
    StackType stack;
    init_stack(&stack);
    here = entry;
    while (maze[here.row][here.column] != 'x') {
        row = here.row;
        column = here.column;
        maze[row][column] = '.';
        maze_print(maze);
        
        printf("현재 위치: (%d,%d)\n", row, column);
        
        // 상하좌우 위치 확인
        push_loc(&stack, row - 1, column);  // 위
        push_loc(&stack, row + 1, column);  // 아래
        push_loc(&stack, row, column - 1);  // 왼쪽
        push_loc(&stack, row, column + 1);  // 오른쪽
        
        // 스택 내용 출력
        stack_print(&stack);
        
        if (is_empty(&stack)) {
            printf("실패\n");
            return 0; // 수정: 반환 값 추가
        }
        else {
            here = pop(&stack);
            printf("다음 위치: (%d,%d)\n", here.row, here.column);
        }
    }
    printf("성공\n");
    return 0; // 성공 시 반환값을 0으로 수정
}
```