---
date created: 목요일, 3월 27일 2025, 9:13:47 오후
date modified: 목요일, 3월 27일 2025, 9:21:09 오후
title: 0327 숙제
과목:
  - "[[자료 구조]]"
---

# 0327 숙제

원본 소스코드 변수명에 약간의 수정을 가한 버전은 아레와 같습니다

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_STACK_SIZE 100
#define MAZE_SIZE 6 // 추가: MAZE_SIZE 정의
typedef struct {
    short row;
    short column;
} element;
typedef struct {
    element data[MAX_STACK_SIZE];
    int top;
} StackType;
// 스택 초기화 함수
void init_stack(StackType* stack)
{
    stack->top = -1;
}
// 공백 상태 검출 함수
int is_empty(StackType* stack)
{
    return (stack->top == -1);
}
// 포화 상태 검출 함수
int is_full(StackType* stack)
{
    return (stack->top == (MAX_STACK_SIZE - 1));
}
// 삽입함수
void push(StackType* stakc, element item)
{
    if (is_full(stakc)) {
        fprintf(stderr, "스택 포화 에러\n");
        return;
    }
    else stakc->data[++(stakc->top)] = item;
}
// 삭제함수
element pop(StackType* stack)
{
    if (is_empty(stack)) {
        fprintf(stderr, "스택 공백 에러\n");
        exit(1);
    }
    else return stack->data[(stack->top)--];
}
element here = { 1,0 }, entry = { 1,0 };
char maze[MAZE_SIZE][MAZE_SIZE] = {
    { '1', '1', '1', '1', '1', '1' },
    { 'e', '0', '1', '0', '0', '1' },
    { '1', '0', '0', '0', '1', '1' },
    { '1', '0', '1', '0', '1', '1' },
    { '1', '0', '1', '0', '0', 'x' },
    { '1', '1', '1', '1', '1', '1' },
};
// 위치를 스택에 삽입
void push_loc(StackType* stack, int row, int column)
{
    if (row < 0 || column < 0) return; // 수정: 범위 검사 추가
    if (maze[row][column] != '1' && maze[row][column] != '.') { // '1'과 '.'인 경우 제외
        element tmp;
        tmp.row = row;
        tmp.column = column;
        push(stack, tmp);
    }
}
// 미로를 화면에 출력한다.
void maze_print(char maze[MAZE_SIZE][MAZE_SIZE])
{
    printf("\n");
    for (int row = 0; row < MAZE_SIZE; row++) {
        for (int column = 0; column < MAZE_SIZE; column++) {
            printf("%c", maze[row][column]);
        }
        printf("\n");
    }
}

int main(void)
{
    int row, column;
    StackType stack;
    init_stack(&stack);
    here = entry;
    while (maze[here.row][here.column] != 'x') {
        row = here.row;
        column = here.column;
        maze[row][column] = '.';
        maze_print(maze);
        
        printf("현재 위치: (%d,%d)\n", row, column);
        
        // 상하좌우 위치 확인
        push_loc(&stack, row - 1, column);  // 위
        push_loc(&stack, row + 1, column);  // 아래
        push_loc(&stack, row, column - 1);  // 왼쪽
        push_loc(&stack, row, column + 1);  // 오른쪽
        
        
        if (is_empty(&stack)) {
            printf("실패\n");
            return 0; // 수정: 반환 값 추가
        }
        else {
            here = pop(&stack);
            printf("다음 위치: (%d,%d)\n", here.row, here.column);
        }
    }
    printf("성공\n");
    return 0; // 성공 시 반환값을 0으로 수정
}
```

지나온 경로를 구별하여 보여주기 위해서
기존에 제공되었던 void maze_print() 함수를 약간 수정하여 사용하였습니다

그 결과 main 함수에 약간의 수정이 있었습니다

```c
printf("길\n");  
    printf("\n");  
for (int row = 0; row < MAZE_SIZE; row++) {  
    for (int column = 0; column < MAZE_SIZE; column++) {  
        if (maze[row][column] == '.'| maze[row][column] == 'x') printf("_");  
        else printf("%c", maze[row][column]);  
  
    }  
    printf("\n");  
}
```

return 0; 바로 위 부분에 해당 코드가 추가되었습니다
해당 코드는 길찾기가 끝난 미로 전체를 순회하며 지나온 길 or 끝 인 경우에는 \_로 출력하고 그 외에는 기존의 상태를 출력하게 되어있습니다

```text
111111
..1001
1...11
101.11
101..x
111111
현재 위치: (4,4)
다음 위치: (4,5)
성공
```
이렇게 미로를 찾은뒤
